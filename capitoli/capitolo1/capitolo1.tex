% crea il CAPITOLO
\chapter{Introduzione}
% imposta l'intestazione di pagina
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}
In questo lavoro di tesi si vuole unire l'espressività della programmazione ad agenti con l'efficienza della simulazione di agenti in un unico ambiente di sviluppo per gli agenti ispirati al modello BDI.

%In questo lavoro di tesi si vuole realizzare un nuovo linguaggio ad agenti, che si ispira al modello BDI di AgentSpeak, che permetta di essere utilizzato in ambienti o piattaforme differenti, ovvero sia simulati che reali.

\paragraph{Obiettivo del lavoro.}

L'obiettivo del lavoro di tesi è quello di sviluppare un ambiente che unisca l'espressività della programmazione ad agenti all'efficienza della simulazione di agenti.
Si vuole quindi utilizzare la definizione di AgentSpeak, che si basa sul modello BDI, estendendola per definire un linguaggio ad agenti creando un interprete in Prolog per la programmazione ad agenti.
Tramite l'utilizzo della libreria tuProlog si è potuta aggiungere all'interprete una forte flessibilità, poichè questa libreria ha tra le sue caratteristiche il supporto alla programmazione multi-paradigma, permettendo così di utilizzare il linguaggio su ambienti differenti, sia reali che simulati.

%L'obiettivo del lavoro di tesi è quello utilizzare la definizione di agenti BDI fatta da AgentSpeak per definire un nuovo linguaggio ad agenti al quale, inoltre, si è voluto aggiungere anche una caratteristica di flessibilità. Quest'ultima è stata raggiunta grazie all'utilizzo della libreria tuProlog che ha permesso di definire un linguaggio che possa essere utilizzato da interpreti realizzati su ambienti e piattaforme differenti accomunate dall'utilizzo di questa libreria.

AgentSpeak è un linguaggio orientato agli agenti basato sulla programmazione logica e l'architettura BDI per programmare agenti autonomi. Il modello BDI (Beliefs, Desires, Intentions) implementa gli aspetti principali del ragionamento umano e consente di programmare agenti intelligenti.
tuProlog è una libreria che permette di sfruttare il linguaggio Prolog, incapsulato in un core minimale, all'interno di applicazioni e infrastrutture distribuite.

Come detto precedentemente, si è voluto unificare la programmazione con la simulazione per creare un unico ambiente per gli agenti che fosse espressivo e performante. Per la simulazione è implementata un'incarnazione all'interno del meta-simulatore Alchemist, collegato all'interprete Prolog tramite la libreria tuProlog, all'interno della quale è presente il ciclo di ragionamento dell'agente.
Quest'ultimo è creato partendo da quello proposto da Jason e permette l'esecuzione di agenti e la gestione dei vari eventi che sono poi inoltrati alle specifiche teorie degli agenti.


%Si vuole mostrare, inoltre, come è possibile creare un interprete all'interno del meta-simulatore Alchemist, realizzando un'opportuna incarnazione, che sfrutta il modello di agenti BDI definito da AgentSpeak e l'implementazione di Jason, in particolare relativamente al ciclo di ragionamento, e che permette l'esecuzione di agenti, definiti tramite le teorie utilizzando il nuovo linguaggio, in un ambiente simulato.

Alchemist è un simulatore per il calcolo pervasivo, aggregato e naturale, che si basa su un meta-modello flessibile, il quale permette di realizzare implementazioni di modelli completamente diversi tra loro.
Jason è un interprete di una versione estesa di AgentSpeak che implementa un linguaggio e fornisce una piattaforma per sviluppare sistemi multi-agente.

\paragraph{Benefici dell'approccio scelto.}
Il beneficio che si vuole ottenere da questo lavoro è appunto la possibilità di disporre di un unico ambiente che abbia il focus sia sulla programmazione ad agenti che la simulazione di agenti permettendo da un lato di sfruttare a pieno l'espressività del modello BDI e del linguaggio AgentSpeak e dall'altro fornire una soluzione prestazionale per la simulazione di agenti grazie alla potenza computazionale di Alchemist e alla flessibilità del suo meta-modello.

%Il beneficio del linguaggio risiede intrinsecamente nell'architettura del modello ad agenti BDI poichè cerca di esprimere tutto il potenziale del paradigma ad agenti.
%In particolare con la definizione di questo nuovo linguaggio si vuole fornire una soluzione per poter sfruttare a pieno l'implementazione dell'agente separando le sue competenze da quelle, invece, puramente demandate all'interprete.
In questo modo all'interno dell'interprete Prolog, ovvero nel linguaggio, saranno definiti solo API per reagire o scatenare determinati eventi mentre la parte di scheduling e gestione del modello saranno realizzati dall'implementazione dell'interprete.
L'agente quindi potrà avere comportamenti diversi in base a come verrà realizzato l'interprete del linguaggio, in questo caso in Alchemist, implementando:
\begin{itemize}
\item funzioni di prelazione relative a selezione di piani e intenzioni;
\item gestione dei messaggi;
\item gestione dell'ambiente esterno;
\item selezione degli eventi da far gestire all'agente.
\end{itemize}

Inoltre, si è scelto di appoggiarsi a soluzioni, quali Alchemist e tuProlog, già ben formate e supportate da una community che ne garantisce la stabilità e il miglioramento nel tempo.
In questo modo si è sicuri che quanto verrà realizzato all'interno del progetto potrà continuare ad essere utilizzato e migliorato con uno sforzo manutentivo sicuramente minore.

\paragraph{Struttura dell'elaborato.}
In questo capitolo è stato descritto l'obiettivo del lavoro ed i benefici che si vogliono ottenere.
A seguire è accennato il contenuto dei prossimi capitoli presenti in questo lavoro di tesi.

Nel \cref{chap:soa} sono descritti inizialmente i lavori correlati al modello ad agenti, ai sistemi multi-agente e sistemi distribuiti, a cui segue una descrizione del modello ad agenti formalizzato da AgentSpeak e del ciclo di ragionamento utilizzato dall'interprete Jason.
Successivamente sono descritte le caratteristiche di tuProlog, Alchemist e del modello SpatialTuples, il quale definisce un'estensione del modello base di tuple per i sistemi multi-agente.

Nel \cref{chap:agentspeak-2p} è definito il nuovo linguaggio ad agenti, il quale unisce la solidità del modello AgentSpeak alle semantiche operazionali del ciclo di ragionamento Jason, e le relative API messe a disposizione per poter programmare l'operato di un agente.
All'interno del capitolo è descritto come avviene la gestione delle intenzioni nella teoria dell'agente ed inoltre sono presenti alcuni esempi base che mostrano il funzionamento del linguaggio.

Nel \cref{chap:agentspeak-2p-alchemist} è iniziata la descrizione dell'implementazione dell'interprete che, per questo progetto di tesi, è stato realizzato all'interno del simulatore Alchemist.
Inizia dall'analisi del mapping per proseguire con la descrizione della libreria, implementata per gestire le primitive del linguaggio che è stato definito, e di alcune situazioni, come la gestione delle azioni e lo spostamento del nodo, in cui questa è stata utilizzata per la gestire il collegamento tra l'interprete e la teoria.

Nel \cref{chap:impl} si è scesi più nello specifico dell'implementazione dell'interprete descrivendo come sono state create le varie classi, in modo particolare le entità Incarnation, Node e Action.
Successivamente è mostrato un ulteriore dettaglio sull'implementazione di alcune funzionalità peculiari dell'interprete, quali la gestione dei messaggi attraverso l'agente Postman, la referenziazione di oggetti Java nelle teorie tramite tuProlog e il modo in cui sono create le intenzioni.
A seguire sono accennate brevemente le caratteristiche dei tool di sviluppo utilizzati e di come scrivere la configurazione di una simulazione.

Nel \cref{chap:validation} è descritto uno scenario di test noto nei sistemi multi-agente, il problema dei Goldminers, e sono descritte le classi e le teorie implementate per poterlo realizzare.
All'interno del capitolo è presente una sezione per spiegare come è stato possibile tematizzare la simulazione; grazie allo stile creato è stato possibile controllare lo sviluppo dello scenario nel tempo in maniera più semplice.
Nella sezione delle metriche di progetto, sono descritti alcuni indicatori che permettono di analizzare meglio il lavoro svolto.

Infine, nel \cref{chap:conclusions}, sono descritti e analizzati i risultati ottenuti sia attraverso il linguaggio che tramite la definizione dell'interprete.